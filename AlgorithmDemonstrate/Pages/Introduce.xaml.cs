using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace AlgorithmDemonstrate.Pages
{
    /// <summary>
    /// Introduce.xaml 的交互逻辑
    /// </summary>
    public partial class Introduce : Page
    {
        public Introduce()
        {
            InitializeComponent();
        }

        private void SelectBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            switch (this.SelectBox.SelectedIndex)
            {
                case 0:
                    this.IntroduceTextBox.Text = "\n　　冒泡排序（Bubble Sort）是一种简单的排序算法。 它多次访问数据序列进行排序，每次比较两个数据，如果顺序错误，就交换它们。 算法将持续重复执行该操作直到不需要进一步交换，这意味着该数据序列已排序完成。 该算法的名称来源于排序时较小的元素通过不断交换位置，缓慢“浮动”到了整个数据序列的顶端，所以将该算法叫做冒泡排序。\n　　冒泡排序的详细运作方式如下：\n　　1)比较相邻的数据，如果前面的数据比后面的数据大，则交换。\n　　2)对从第一个开始到最后一个的所有数据做同样的操作，当全部执行完一遍后，最后的数据就是最大的数了。\n　　3)将已确定的最大的数剔除，回到第一个位置，对其余数据再次执行一样的操作。\n　　4)在不断的执行中，可以不断的确定当前剩余数据中最大的数，将每个循环中的最大的数放置在尾端，最终便可完成数据排序。\n　　冒泡排序虽然是最简单掌握和最简单实现的排序算法，但使用它进行大量元素的数据序列进行排序是效率很低的。冒泡排序的平均时间复杂度为O(n2)，空间复杂度为O(n)。由于其易懂性，冒泡排序通常被当做排序算法入门的教材。";
                    break;
                case 1:
                    this.IntroduceTextBox.Text = "\n　　双向冒泡排序（Cocktail Sort）是冒泡排序的一种变形，又称鸡尾酒排序。\n　　它与冒泡排序一样多次访问数据序列、每次比较两个数据，如果顺序错误，就交换它们。算法持续重复执行操作直到排序完成。不同的地方在于，遍历数列时，冒泡排序永远是从低到高来进行遍历，而双向冒泡排序在到达尾端时不会跳到首端，而是会从尾端直接开始往前进行遍历。\n　　双向冒泡排序的详细运作方式如下：\n　　1)比较相邻的数据，如果前面的数据比后面的数据大，则交换。\n　　2)对从第一个开始到最后一个的所有数据做同样的操作，当全部执行完一遍后，最后的数据就是最大的数了。\n　　3)将已确定的最大的数剔除，从其余数据的最后一个开始到第一个，对其余数据再次执行一样的操作，此时最前的数据就是最小的数据了。\n　　4)将已确定的最小的数剔除，在其余数据中不断执行这个往返遍历的操作。\n　　5)在不断的执行中，可以不断的确定当前剩余数据中最大的数和最小的数，将每个循环中的最大的数放置在尾端、最小的数放置在首端，最终便可完成数据排序。\n　　双向冒泡排序虽然只是冒泡排序算法的一种变形，但其对于一些特殊数据序列拥有很大的效率优势，虽然使用它进行大量乱序元素的数据序列进行排序时效率依然很低的。冒泡排序的平均时间复杂度为O(n2)，空间复杂度为O(n)。";
                    break;
                case 2:
                    this.IntroduceTextBox.Text = "\n　　奇偶排序（Odd-Even Sort）又称奇偶换位排序或砖排序。最初发明来用于并行计算，与冒泡排序特点类似，是一种比较排序，所以也是一种相对简单的排序算法。在奇偶排序算法中，通过查找数据序列中所有相邻的一个奇数和一个偶数数字对（先奇数后偶数），如果前者大于后者，则进行交换，下一步查找数据序列中所有相邻的一个偶数和一个奇数数字对（先偶数后奇数），如果前者大于后者，则进行交换。因排序过程依靠奇数和偶数的交替，所以该算法被叫做奇偶排序。\n　　奇偶排序的详细运作方式如下：\n　　1)查找数据序列中的所有先奇数后偶数的数字对，如果前者大于后者，则进行交换。\n　　2)上述交换完成一次后，查找数据序列中的所有先偶数后奇数的数字对，如果前者大于后者，则进行交换。\n　　3)重复以上两个步骤直至没有数字对需要进行交换，则排序完成。\n　　奇偶排序是一种针对当时一种新型处理器设计的新型精巧算法，该处理器恰好是两个计算组，进行该种操作可以拥有较高的优势。但其实际最坏时间复杂度依然为O(n2)，进行大量数据序列排序时依然不具备优势。";
                    break;
                case 3:
                    this.IntroduceTextBox.Text = "\n　　梳排序（Comb Sort）是由Wlodzimierz Dobosiewicz在1980年发明的一种不稳定排序算法，在1991年在杂志中进行推广。梳排序是由泡沫排序和快速排序改良而来，设计目的有消除在阵列尾部的造成泡沫排序效率低、速度慢的小数值。在泡沫排序中，只比较数字序列中相邻的两项，梳排序不只是比较相邻的项，而是设置一个动态的间距，先使用较大的间距，后使用较小的间距，间距在不断的遍历过程中不断减小，在间距最后为1时，即判断项回归相邻项时只需做最后的检查修正即可完成整个排序的过程。\n　　在梳排序中，间距的递减率决定了梳排序的效率，如果该值过小，一个循环中的比较次数就变高了，如果该值太大，就不能很好的消除序列尾部的小数值。原作者以随机数做试验，得出了最有效的递减率为1.3，后有人提议使用一个新的数值，换算成乘法以提高效率，最终选择的递增率为0.8。 \n　　梳排序的详细运作方式如下：\n　　1)从数据序列的左侧第一位开始，按指定间隔对比两个数据的大小，如果靠左侧的数据大于靠右侧的数据，则交换。\n　　2)重复执行第一条直至间隔为1且没有数字对需要交换，则排序完成。初始间隔值等于数据序列的长度，每次重复执行时间隔按一定递减率降低，数值保持为整形，最终为1。\n　　梳排序是一种较为高效的、解决了其他排序算法中部分问题的排序算法，梳排序的效率在刚开始的时候最高，随着间距减小，效率也会逐步变差。如果在间距小于某个值时更改使用其他适用于接近顺序的数据序列的排序算法，或许可以提高整体的效能。梳排序算法的平均时间复杂度为Ω(n2/2p)，其中p表示递增率；算法的空间复杂度为O(1)。";
                    break;
                case 4:
                    this.IntroduceTextBox.Text = "\n　　地精排序（Gnome Sort）又称侏儒排序，最初由伊朗计算机工程师Hamid Sarbazi-Azad在2000年提出，此后Dick Grune也描述了这个算法，称其为地精排序。地精排序算法与插入排序有很高的相似度，移动元素的方式与冒泡排序很相似。从逻辑上说地精排序非常简单，从头开始遍历数据序列，当前元素如果比前一个元素大，就将其与前一个数据互换并继续检查该数据，否则检查下一个。\n　　地精排序的详细运作方式如下：\n　　1)从数据序列的左侧第一位开始，如果该数据比前一个数据大，则将其与前一个元素互换并继续检查它。\n　　2)如果该数据不大于前一个数据，则检查下一个数据。\n　　3)当检查到最后一位时，排序就完成了。\n　　地精排序的神奇之处在于他只需要从头到尾执行一次便可以完成排序，逻辑也非常简单，但是只有一重循环不代表时间复杂度小。地精排序的平均时间复杂度依然为O(n2)，空间复杂度则为O(1)。算法优点在于排序稳定，使用空间小，但效率较低。";
                    break;
                case 5:
                    this.IntroduceTextBox.Text = "\n　　快速排序（Quick Sort）又称划分交换排序，最初由英国计算机科学家Charles Antony Richard Hoare（昵称Tony Hoare，中文翻译为托尼·霍尔）提出。快速排序通常明显的快于其他算法。其使用分治法策略来把一个序列分成两个子序列。\n　　快速排序算法的详细运作方式如下：\n　　1)从数据序列中挑出一个数据，称为基准。\n　　2)重新排序数据序列，所有比基准小的数据放在其前面，所有比基准大的数据摆在其后面，相同的则任意一边均可，该操作完成后，基准就位于数据序列中间，这个操作称作分区操作。\n　　3)再一次将两个分区进行选择基准并移动数据，循环递归，知道递归到最底部，每个分区的大小是零或是一时，排序则完成了。\n　　实现上述操作通常需要用到很多的额外存储空间，但现已有一个比较复杂的方案，可以使其空间复杂度得到优化，称为原地分区版本，但该版本牺牲了稳定性来换取性能和空间优化。\n　　快速排序是二叉查找树的一个空间最优版本，其直接竞争对象是堆排序和归并排序，通常情况下堆排序比快速排序稍慢，归并排序则在稳定性方面远胜于快速排序。快速排序的平均时间复杂度为O(nlogn)，空间复杂度则根据实现的方式不同而不同。";
                    break;
                case 6:
                    this.IntroduceTextBox.Text = "\n　　选择排序（Selection Sort）是一种简单的排序算法。其工作原理大致为：不断从未排序数据序列中找到最小的元素，将其摆放到排序数据序列的末端，当所有未排序数据序列都已移动完毕后排序就完成了。\n　　选择排序算法的详细运作方式如下：\n　　1)从数据序列中从前到后遍历找出最小的一个数据，将其与摆放在数据序列的第一位的数据交换。现在称前面的数据序列为已排序数据序列，后面待排序的数据序列为未排序数据序列。\n　　2)继续从未排序数据序列中从前到后遍历查找一个最小的数据，将其与摆放在已排序数据序列后面一个数据交换。循环此步骤直至未排序数据序列为空，则排序完成。\n　　选择排序中如果某个数据位于正确的位置上，那么这个数据自始至终都不会被移动；每次交换都至少有一个数据摆放在了最终正确的位置上，整个排序过程所需的交换次数极少。同时，交换时不需要花费其他的空间，属于原地交换，故空间复杂度低。选择排序的平均时间复杂度为O(n2)，空间复杂度则为O(n)。";
                    break;
                case 7:
                    this.IntroduceTextBox.Text = "\n　　双向选择排序（Selection Cocktail Sort）是选择排序的一种简单的变形。其工作原理与选择排序相似，不同点为双向选择排序在遍历到末端时，下一次会从后端往前遍历而不是跳回首端开始。\n　　双向选择排序算法的详细运作方式如下：\n　　1)从数据序列中从前到后找出最小的一个数据，将其与摆放在数据序列的第一位的数据交换。现在称前面的数据序列为已排序数据序列，后面待排序的数据序列为未排序数据序列。\n　　2)从未排序数据序列中从后往前查找一个最小的数据，将其与摆放在已排序数据序列后面一个数据交换。然后从前往后遍历、再然后从后往前遍历。循环此步骤直至未排序数据序列为空，则排序完成。\n　　双向选择排序拥有选择排序拥有的所有优点。同时在某些特殊的数据序列中拥有特殊的高效率。双向选择排序的平均时间复杂度依然为O(n2)，空间复杂度则为O(n)。";
                    break;
                case 8:
                    this.IntroduceTextBox.Text = "\n　　堆排序（Heap Sort）是利用数据结构堆所发明的一种排序算法。堆（Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。[5]堆近似于完全二叉树的结构，其子节点的键值或索引总是小于它的父节点。堆排序算法首先将所有数据进行重排序以符合堆的条件，然后再进行堆处理。\n　　堆排序算法的详细运作方式如下：\n　　1)重排数据序列中的数据以符合堆的条件，然后创建堆。\n　　2)将堆首和堆尾互换。\n　　3)将堆的大小缩小1，并将新数组顶端数据调整到对应的位置\n　　4)循环这些步骤，直到堆的尺寸为1，此时排序完成。\n　　堆排序通过一维数组来实现，堆中的最大值总位于根节点。堆排序的平均时间复杂度为O(nlogn)，空间复杂度为O(n)。";
                    break;
                case 9:
                    this.IntroduceTextBox.Text = "\n　　插入排序（Insertion Sort）是简单直观的一种排序算法。它通过构建一个有序序列，解析未序列化的数据，从已排序的序列中从后往前扫描，找到适当的位置并插入。 插入排序通常原地执行，只使用1的额外空间用于排序。 有必要逐个移动已排序数据为待插入数据提供插入空间。\n　　插入排序算法的详细运作方式如下：\n　　1)从数据序列中的第一个数据开始，可以将此数据视为已排序\n　　2)指向下一个数据，并按照从后往前的顺序对已排序数据进行扫描\n　　3)如果扫描到的已排序数据大于新数据，则将数据移动到后面一个位置\n　　4)循环第3步，直到扫描到的已排序数据小于新数据\n　　5)在此位置后面插入这个新数据\n　　6)不断循环第2-5步，直至排序完成\n　　插入排序算法的交换操作和比较操作都不少，但其优势在于只遍历一遍数据序列即可完成排序，如果比较操作耗费资源更多还可使用二分法等来减少比较操作的数量。插入排序的平均时间复杂度为O(n2)，空间复杂度为O(n)。";
                    break;
                case 10:
                    this.IntroduceTextBox.Text = "\n　　希尔排序（Shell Sort）又称递减增量排序算法，改进于插入排序，是一种非稳定排序算法。插入排序通常而言非常低效，其每次只能将数据移动一位，所以Donald Shell改进了插入排序算法，提出了希尔排序算法。希尔排序将数据序列划分为几个区域来提升插入排序的性能，使得一个数据一次可以朝着最终位置前进很大的一步。随着步长的不断缩小，当步长为1时，希尔排序将变成普通的插入排序。\n　　希尔排序算法的详细运作方式如下：\n　　1)从数据序列中的第1个数据开始，每相隔n的数据组为一组，其中n为步长\n　　2)将每个组内的数据序列，按插入排序进行排序\n　　3)循环缩小步长，不断将新组成的数据序列用插入排序进行排序，直到步长为1\n　　4)在步长为1时，对全部数据序列进行插入排序，此时全部数据序列已经接近排序完成，有极高的效率，随后排序操作便完成了。\n　　希尔排序是对插入排序的一种极大优化，实际运行效率中，希尔排序在各方面都要优于插入排序，虽然其本质依然是插入排序，但我们从希尔排序中可以了解到，对算法这种构思精妙的东西的一点点微不足道的改进都会造成大爆炸般的影响。影响希尔排序的效率的一大因素是步长要如何设定，在多年的研究之后，我们可以得知有了多种不同情况下的最坏情况复杂度的步长序列计算方式，其中较常使用的是Sedgewick提出的(1, 5, 19, 41, 109,...)。希尔排序的最优时间复杂度为O(n)，空间复杂度为O(n)。";
                    break;
                case 11:
                    this.IntroduceTextBox.Text = "\n　　归并排序（Merge Sort）在1945年由John von Neumann基于归并操作创建并提出，是一种有效的排序算法。该算法拥有较高的效率，是采用分治法的一个典型应用，并且各层的分治法和归并递归可以同时进行。归并操作也称为归并算法，是指将两个已经排序好的小序列合并为一个排序好的大序列的操作。\n　　归并排序算法的详细运作方式如下：\n　　1)将一个待排序的数据序列拆分为两个数据序列\n　　2)循环该步骤直至子数据序列只剩一个数据\n　　3)不断使用归并操作合并拆分开的子数据序列\n　　4)最终得到完全排序完成的完整数据序列\n　　归并程序是稳定的，对于巨大的数据序列，其拥有快速和稳定的优势，其缺点在于其需要用到的空间较大，但依然有特殊优化模型减少其使用的空间。归并排序特别适合在对象内、多线程操作时使用，因其最坏时间复杂度与平均时间复杂度相同。归并排序的平均时间复杂度为O(nlogn)，空间复杂度为O(n)。";
                    break;
                case 12:
                    this.IntroduceTextBox.Text = "\n　　臭皮匠排序（Stooge Sort），算法如其名，虽说三个臭皮匠可以顶个诸葛亮，但是这里只有一个臭皮匠。臭皮匠排序非常低效，甚至比冒泡排序还要慢。但与其效率成巨大反差的是，不少科学家坚持形容臭皮匠排序为最漂亮的排序算法。\n　　臭皮匠排序算法的详细运作方式如下：\n　　1)如果最后一个数据小于第一个数据，则交换这两个数据\n　　2)选择前三分之二的数据，使用第一步进行不断的遍历\n　　3)选择后三分之二的数据，使用第一步进行不断的遍历\n　　4)再一次选择前三分之二的数据，使用第一步进行不断的遍历\n　　臭皮匠排序可谓“最蠢的”排序算法，算法本身并不知道何时排序完成了，只是不断的进行遍历，将所有可能的情况都对比一遍之后，才会结束排序算法。所以对于臭皮匠排序而言，无论数据序列的形态如何，其进行的比较次数都是固定的，永远与序列长度有关。臭皮匠排序的最坏时间复杂度为O(nlog3/log1.5)，空间复杂度为O(n)。";
                    break;
                default:
                    break;
            }
        }
    }
}
